<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cpl_csv.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3-20001105 on Sun Mar 4 23:32:43 2001 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>cpl_csv.c</h1><div class="fragment"><pre>00001 <font class="comment">/******************************************************************************</font>
00002 <font class="comment"> * Copyright (c) 1999, Frank Warmerdam</font>
00003 <font class="comment"> *</font>
00004 <font class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a</font>
00005 <font class="comment"> * copy of this software and associated documentation files (the "Software"),</font>
00006 <font class="comment"> * to deal in the Software without restriction, including without limitation</font>
00007 <font class="comment"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</font>
00008 <font class="comment"> * and/or sell copies of the Software, and to permit persons to whom the</font>
00009 <font class="comment"> * Software is furnished to do so, subject to the following conditions:</font>
00010 <font class="comment"> *</font>
00011 <font class="comment"> * The above copyright notice and this permission notice shall be included</font>
00012 <font class="comment"> * in all copies or substantial portions of the Software.</font>
00013 <font class="comment"> *</font>
00014 <font class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</font>
00015 <font class="comment"> * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</font>
00016 <font class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</font>
00017 <font class="comment"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</font>
00018 <font class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</font>
00019 <font class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</font>
00020 <font class="comment"> * DEALINGS IN THE SOFTWARE.</font>
00021 <font class="comment"> ******************************************************************************</font>
00022 <font class="comment"> *</font>
00023 <font class="comment"> * cpl_csv.c: Support functions for accessing CSV files.</font>
00024 <font class="comment"> *</font>
00025 <font class="comment"> * $Log$
00025 <font class="comment"> * Revision 1.2  2001/03/05 04:58:33  warmerda
00025 <font class="comment"> * updated
00025 <font class="comment"> *</font>
00026 <font class="comment"> * Revision 1.10  2001/01/17 15:32:19  warmerda</font>
00027 <font class="comment"> * Include /usr/share/epsg_csv and share/epsg_csv in csv search path.</font>
00028 <font class="comment"> *</font>
00029 <font class="comment"> * Revision 1.9  2000/12/12 19:34:36  warmerda</font>
00030 <font class="comment"> * Use CSV_DATA_DIR if defined.</font>
00031 <font class="comment"> *</font>
00032 <font class="comment"> * Revision 1.8  2000/08/22 04:33:33  warmerda</font>
00033 <font class="comment"> * added support for /usr/local/shared/epsg_csv</font>
00034 <font class="comment"> *</font>
00035 <font class="comment"> * Revision 1.7  1999/12/03 14:42:59  warmerda</font>
00036 <font class="comment"> * Passing a NULL filename into CSVAccess() now results in a graceful</font>
00037 <font class="comment"> * failure to open the file.</font>
00038 <font class="comment"> *</font>
00039 <font class="comment"> * Revision 1.6  1999/06/26 17:28:51  warmerda</font>
00040 <font class="comment"> * Fixed reading of records with newlines embedded in quoted strings.</font>
00041 <font class="comment"> *</font>
00042 <font class="comment"> * Revision 1.5  1999/05/04 03:07:24  warmerda</font>
00043 <font class="comment"> * avoid warning</font>
00044 <font class="comment"> *</font>
00045 <font class="comment"> * Revision 1.4  1999/04/28 19:59:56  warmerda</font>
00046 <font class="comment"> * added some doxygen style documentation</font>
00047 <font class="comment"> *</font>
00048 <font class="comment"> * Revision 1.3  1999/03/17 19:53:15  geotiff</font>
00049 <font class="comment"> * sys includes moved to cpl_serv.h</font>
00050 <font class="comment"> *</font>
00051 <font class="comment"> * Revision 1.2  1999/03/10 16:54:42  geotiff</font>
00052 <font class="comment"> * Added use of the GEOTIFF_CSV environment variable to locate CSV files.</font>
00053 <font class="comment"> *</font>
00054 <font class="comment"> * Revision 1.1  1999/03/09 15:57:04  geotiff</font>
00055 <font class="comment"> * New</font>
00056 <font class="comment"> *</font>
00057 <font class="comment"> * Revision 1.2  1999/02/24 16:23:21  warmerda</font>
00058 <font class="comment"> * added lots</font>
00059 <font class="comment"> *</font>
00060 <font class="comment"> * Revision 1.1  1999/01/05 16:52:36  warmerda</font>
00061 <font class="comment"> * New</font>
00062 <font class="comment"> *</font>
00063 <font class="comment"> */</font>
00064 
00065 <font class="preprocessor">#include "cpl_csv.h"</font>
00066 <font class="preprocessor">#include "geo_tiffp.h"</font>
00067 
00068 <font class="comment">/* ==================================================================== */</font>
00069 <font class="comment">/*      The CSVTable is a persistant set of info about an open CSV      */</font>
00070 <font class="comment">/*      table.  While it doesn't currently maintain a record index,     */</font>
00071 <font class="comment">/*      or in-memory copy of the table, it could be changed to do so    */</font>
00072 <font class="comment">/*      in the future.                                                  */</font>
00073 <font class="comment">/* ==================================================================== */</font>
00074 <font class="keyword">typedef</font> <font class="keyword">struct </font>ctb {
00075     FILE        *fp;
00076 
00077     <font class="keyword">struct </font>ctb *psNext;
00078 
00079     <font class="keywordtype">char</font>        *pszFilename;
00080 
00081     <font class="keywordtype">char</font>        **papszFieldNames;
00082 
00083     <font class="keywordtype">char</font>        **papszRecFields;
00084 } CSVTable;
00085 
00086 <font class="keyword">static</font> CSVTable *psCSVTableList = NULL;
00087 
00088 <font class="comment">/************************************************************************/</font>
00089 <font class="comment">/*                             CSVAccess()                              */</font>
00090 <font class="comment">/*                                                                      */</font>
00091 <font class="comment">/*      This function will fetch a handle to the requested table.       */</font>
00092 <font class="comment">/*      If not found in the ``open table list'' the table will be       */</font>
00093 <font class="comment">/*      opened and added to the list.  Eventually this function may     */</font>
00094 <font class="comment">/*      become public with an abstracted return type so that            */</font>
00095 <font class="comment">/*      applications can set options about the table.  For now this     */</font>
00096 <font class="comment">/*      isn't done.                                                     */</font>
00097 <font class="comment">/************************************************************************/</font>
00098 
00099 <font class="keyword">static</font> CSVTable *CSVAccess( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFilename )<font class="keyword"></font>
00100 <font class="keyword"></font>
00101 <font class="keyword"></font>{
00102     CSVTable    *psTable;
00103     FILE        *fp;
00104 
00105     <font class="keywordflow">if</font>( pszFilename == NULL )
00106         <font class="keywordflow">return</font> NULL;
00107 
00108 <font class="comment">/* -------------------------------------------------------------------- */</font>
00109 <font class="comment">/*      Is the table already in the list.                               */</font>
00110 <font class="comment">/* -------------------------------------------------------------------- */</font>
00111     <font class="keywordflow">for</font>( psTable = psCSVTableList; psTable != NULL; psTable = psTable-&gt;psNext )
00112     {
00113         <font class="keywordflow">if</font>( EQUAL(psTable-&gt;pszFilename,pszFilename) )
00114         {
00115             <font class="comment">/*</font>
00116 <font class="comment">             * Eventually we should consider promoting to the front of</font>
00117 <font class="comment">             * the list to accelerate frequently accessed tables.</font>
00118 <font class="comment">             */</font>
00119             
00120             <font class="keywordflow">return</font>( psTable );
00121         }
00122     }
00123 
00124 <font class="comment">/* -------------------------------------------------------------------- */</font>
00125 <font class="comment">/*      If not, try to open it.                                         */</font>
00126 <font class="comment">/* -------------------------------------------------------------------- */</font>
00127     fp = VSIFOpen( pszFilename, <font class="stringliteral">"r"</font> );
00128     <font class="keywordflow">if</font>( fp == NULL )
00129         <font class="keywordflow">return</font> NULL;
00130 
00131 <font class="comment">/* -------------------------------------------------------------------- */</font>
00132 <font class="comment">/*      Create an information structure about this table, and add to    */</font>
00133 <font class="comment">/*      the front of the list.                                          */</font>
00134 <font class="comment">/* -------------------------------------------------------------------- */</font>
00135     psTable = (CSVTable *) CPLCalloc(<font class="keyword">sizeof</font>(CSVTable),1);
00136 
00137     psTable-&gt;fp = fp;
00138     psTable-&gt;pszFilename = CPLStrdup( pszFilename );
00139     psTable-&gt;psNext = psCSVTableList;
00140     
00141     psCSVTableList = psTable;
00142 
00143 <font class="comment">/* -------------------------------------------------------------------- */</font>
00144 <font class="comment">/*      Read the table header record containing the field names.        */</font>
00145 <font class="comment">/* -------------------------------------------------------------------- */</font>
00146     psTable-&gt;papszFieldNames = CSVReadParseLine( fp );
00147 
00148     <font class="keywordflow">return</font>( psTable );
00149 }
00150 
00151 <font class="comment">/************************************************************************/</font>
00152 <font class="comment">/*                            CSVDeaccess()                             */</font>
00153 <font class="comment">/************************************************************************/</font>
00154 
00155 <font class="keywordtype">void</font> CSVDeaccess( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFilename )<font class="keyword"></font>
00156 <font class="keyword"></font>
00157 <font class="keyword"></font>{
00158     CSVTable    *psLast, *psTable;
00159     
00160 <font class="comment">/* -------------------------------------------------------------------- */</font>
00161 <font class="comment">/*      A NULL means deaccess all tables.                               */</font>
00162 <font class="comment">/* -------------------------------------------------------------------- */</font>
00163     <font class="keywordflow">if</font>( pszFilename == NULL )
00164     {
00165         <font class="keywordflow">while</font>( psCSVTableList != NULL )
00166             CSVDeaccess( psCSVTableList-&gt;pszFilename );
00167         
00168         <font class="keywordflow">return</font>;
00169     }
00170 
00171 <font class="comment">/* -------------------------------------------------------------------- */</font>
00172 <font class="comment">/*      Find this table.                                                */</font>
00173 <font class="comment">/* -------------------------------------------------------------------- */</font>
00174     psLast = NULL;
00175     <font class="keywordflow">for</font>( psTable = psCSVTableList;
00176          psTable != NULL &amp;&amp; !EQUAL(psTable-&gt;pszFilename,pszFilename);
00177          psTable = psTable-&gt;psNext )
00178     {
00179         psLast = psTable;
00180     }
00181 
00182     <font class="keywordflow">if</font>( psTable == NULL )
00183         <font class="keywordflow">return</font>;
00184 
00185 <font class="comment">/* -------------------------------------------------------------------- */</font>
00186 <font class="comment">/*      Remove the link from the list.                                  */</font>
00187 <font class="comment">/* -------------------------------------------------------------------- */</font>
00188     <font class="keywordflow">if</font>( psLast != NULL )
00189         psLast-&gt;psNext = psTable-&gt;psNext;
00190     <font class="keywordflow">else</font>
00191         psCSVTableList = psTable-&gt;psNext;
00192 
00193 <font class="comment">/* -------------------------------------------------------------------- */</font>
00194 <font class="comment">/*      Free the table.                                                 */</font>
00195 <font class="comment">/* -------------------------------------------------------------------- */</font>
00196     VSIFClose( psTable-&gt;fp );
00197 
00198     CSLDestroy( psTable-&gt;papszFieldNames );
00199     CSLDestroy( psTable-&gt;papszRecFields );
00200     CPLFree( psTable-&gt;pszFilename );
00201 
00202     CPLFree( psTable );
00203 
00204 <font class="comment">/* -------------------------------------------------------------------- */</font>
00205 <font class="comment">/*      Free working buffer in CPLReadLine().                           */</font>
00206 <font class="comment">/* -------------------------------------------------------------------- */</font>
00207     CPLReadLine( NULL );
00208 }
00209 
00210 <font class="comment">/************************************************************************/</font>
00211 <font class="comment">/*                          CSVReadParseLine()                          */</font>
00212 <font class="comment">/*                                                                      */</font>
00213 <font class="comment">/*      Read one line, and return split into fields.  The return        */</font>
00214 <font class="comment">/*      result is a stringlist, in the sense of the CSL functions.      */</font>
00215 <font class="comment">/************************************************************************/</font>
00216 
00217 <font class="keywordtype">char</font> **CSVReadParseLine( FILE * fp )<font class="keyword"></font>
00218 <font class="keyword"></font>
00219 <font class="keyword"></font>{
00220     <font class="keyword">const</font> <font class="keywordtype">char</font>  *pszLine;
00221     <font class="keywordtype">char</font>        *pszWorkLine;
00222     <font class="keywordtype">char</font>        **papszReturn;
00223 
00224     CPLAssert( fp != NULL );
00225     <font class="keywordflow">if</font>( fp == NULL )
00226         <font class="keywordflow">return</font>( NULL );
00227     
00228     pszLine = CPLReadLine( fp );
00229     <font class="keywordflow">if</font>( pszLine == NULL )
00230         <font class="keywordflow">return</font>( NULL );
00231 
00232 <font class="comment">/* -------------------------------------------------------------------- */</font>
00233 <font class="comment">/*      If there are no quotes, then this is the simple case.           */</font>
00234 <font class="comment">/*      Parse, and return tokens.                                       */</font>
00235 <font class="comment">/* -------------------------------------------------------------------- */</font>
00236     <font class="keywordflow">if</font>( strchr(pszLine,<font class="charliteral">'\"'</font>) == NULL )
00237         <font class="keywordflow">return</font> CSLTokenizeStringComplex( pszLine, <font class="stringliteral">","</font>, TRUE, TRUE );
00238 
00239 <font class="comment">/* -------------------------------------------------------------------- */</font>
00240 <font class="comment">/*      We must now count the quotes in our working string, and as      */</font>
00241 <font class="comment">/*      long as it is odd, keep adding new lines.                       */</font>
00242 <font class="comment">/* -------------------------------------------------------------------- */</font>
00243     pszWorkLine = CPLStrdup( pszLine );
00244 
00245     <font class="keywordflow">while</font>( TRUE )
00246     {
00247         <font class="keywordtype">int</font>             i, nCount = 0;
00248 
00249         <font class="keywordflow">for</font>( i = 0; pszWorkLine[i] != <font class="charliteral">'\0'</font>; i++ )
00250         {
00251             <font class="keywordflow">if</font>( pszWorkLine[i] == <font class="charliteral">'\"'</font>
00252                 &amp;&amp; (i == 0 || pszWorkLine[i-1] != <font class="charliteral">'\\'</font>) )
00253                 nCount++;
00254         }
00255 
00256         <font class="keywordflow">if</font>( nCount % 2 == 0 )
00257             <font class="keywordflow">break</font>;
00258 
00259         pszLine = CPLReadLine( fp );
00260         <font class="keywordflow">if</font>( pszLine == NULL )
00261             <font class="keywordflow">break</font>;
00262 
00263         pszWorkLine = (<font class="keywordtype">char</font> *)
00264             CPLRealloc(pszWorkLine,
00265                        strlen(pszWorkLine) + strlen(pszLine) + 1);
00266         strcat( pszWorkLine, pszLine );
00267     }
00268     
00269     papszReturn = CSLTokenizeStringComplex( pszWorkLine, <font class="stringliteral">","</font>, TRUE, TRUE );
00270 
00271     CPLFree( pszWorkLine );
00272 
00273     <font class="keywordflow">return</font> papszReturn;
00274 }
00275 
00276 <font class="comment">/************************************************************************/</font>
00277 <font class="comment">/*                             CSVCompare()                             */</font>
00278 <font class="comment">/*                                                                      */</font>
00279 <font class="comment">/*      Compare a field to a search value using a particular            */</font>
00280 <font class="comment">/*      criteria.                                                       */</font>
00281 <font class="comment">/************************************************************************/</font>
00282 
00283 <font class="keyword">static</font> <font class="keywordtype">int</font> CSVCompare( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFieldValue, <font class="keyword">const</font> <font class="keywordtype">char</font> * pszTarget,
00284                        CSVCompareCriteria eCriteria )<font class="keyword"></font>
00285 <font class="keyword"></font>
00286 <font class="keyword"></font>{
00287     <font class="keywordflow">if</font>( eCriteria == CC_ExactString )
00288     {
00289         <font class="keywordflow">return</font>( strcmp( pszFieldValue, pszTarget ) == 0 );
00290     }
00291     <font class="keywordflow">else</font> <font class="keywordflow">if</font>( eCriteria == CC_ApproxString )
00292     {
00293         <font class="keywordflow">return</font>( EQUAL( pszFieldValue, pszTarget ) );
00294     }
00295     <font class="keywordflow">else</font> <font class="keywordflow">if</font>( eCriteria == CC_Integer )
00296     {
00297         <font class="keywordflow">return</font>( atoi(pszFieldValue) == atoi(pszTarget) );
00298     }
00299 
00300     <font class="keywordflow">return</font> FALSE;
00301 }
00302 
00303 <font class="comment">/************************************************************************/</font>
00304 <font class="comment">/*                            CSVScanLines()                            */</font>
00305 <font class="comment">/*                                                                      */</font>
00306 <font class="comment">/*      Read the file scanline for lines where the key field equals     */</font>
00307 <font class="comment">/*      the indicated value with the suggested comparison criteria.     */</font>
00308 <font class="comment">/*      Return the first matching line split into fields.               */</font>
00309 <font class="comment">/************************************************************************/</font>
00310 
00311 <font class="keywordtype">char</font> **CSVScanLines( FILE *fp, <font class="keywordtype">int</font> iKeyField, <font class="keyword">const</font> <font class="keywordtype">char</font> * pszValue,
00312                      CSVCompareCriteria eCriteria )<font class="keyword"></font>
00313 <font class="keyword"></font>
00314 <font class="keyword"></font>{
00315     <font class="keywordtype">char</font>        **papszFields = NULL;
00316     <font class="keywordtype">int</font>         bSelected = FALSE, nTestValue;
00317 
00318     CPLAssert( pszValue != NULL );
00319     CPLAssert( iKeyField &gt;= 0 );
00320     CPLAssert( fp != NULL );
00321     
00322     nTestValue = atoi(pszValue);
00323     
00324     <font class="keywordflow">while</font>( !bSelected ) {
00325         papszFields = CSVReadParseLine( fp );
00326         <font class="keywordflow">if</font>( papszFields == NULL )
00327             <font class="keywordflow">return</font>( NULL );
00328 
00329         <font class="keywordflow">if</font>( CSLCount( papszFields ) &lt; iKeyField+1 )
00330         {
00331             <font class="comment">/* not selected */</font>
00332         }
00333         <font class="keywordflow">else</font> <font class="keywordflow">if</font>( eCriteria == CC_Integer
00334                  &amp;&amp; atoi(papszFields[iKeyField]) == nTestValue )
00335         {
00336             bSelected = TRUE;
00337         }
00338         <font class="keywordflow">else</font>
00339         {
00340             bSelected = CSVCompare( papszFields[iKeyField], pszValue,
00341                                     eCriteria );
00342         }
00343 
00344         <font class="keywordflow">if</font>( !bSelected )
00345         {
00346             CSLDestroy( papszFields );
00347             papszFields = NULL;
00348         }
00349     }
00350     
00351     <font class="keywordflow">return</font>( papszFields );
00352 }
00353 
00354 <font class="comment">/************************************************************************/</font>
00355 <font class="comment">/*                            CSVScanFile()                             */</font>
00356 <font class="comment">/*                                                                      */</font>
00357 <font class="comment">/*      Scan a whole file using criteria similar to above, but also     */</font>
00358 <font class="comment">/*      taking care of file opening and closing.                        */</font>
00359 <font class="comment">/************************************************************************/</font>
00360 
00361 <font class="keywordtype">char</font> **CSVScanFile( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFilename, <font class="keywordtype">int</font> iKeyField,
00362                     <font class="keyword">const</font> <font class="keywordtype">char</font> * pszValue, CSVCompareCriteria eCriteria )<font class="keyword"></font>
00363 <font class="keyword"></font>
00364 <font class="keyword"></font>{
00365     CSVTable    *psTable;
00366 
00367 <font class="comment">/* -------------------------------------------------------------------- */</font>
00368 <font class="comment">/*      Get access to the table.                                        */</font>
00369 <font class="comment">/* -------------------------------------------------------------------- */</font>
00370     CPLAssert( pszFilename != NULL );
00371 
00372     <font class="keywordflow">if</font>( iKeyField &lt; 0 )
00373         <font class="keywordflow">return</font> NULL;
00374 
00375     psTable = CSVAccess( pszFilename );
00376     <font class="keywordflow">if</font>( psTable == NULL )
00377         <font class="keywordflow">return</font> NULL;
00378 
00379 <font class="comment">/* -------------------------------------------------------------------- */</font>
00380 <font class="comment">/*      Does the current record match the criteria?  If so, just        */</font>
00381 <font class="comment">/*      return it again.                                                */</font>
00382 <font class="comment">/* -------------------------------------------------------------------- */</font>
00383     <font class="keywordflow">if</font>( iKeyField &gt;= 0
00384         &amp;&amp; iKeyField &lt; CSLCount(psTable-&gt;papszRecFields)
00385         &amp;&amp; CSVCompare(pszValue,psTable-&gt;papszRecFields[iKeyField],eCriteria) )
00386     {
00387         <font class="keywordflow">return</font> psTable-&gt;papszRecFields;
00388     }
00389 
00390 <font class="comment">/* -------------------------------------------------------------------- */</font>
00391 <font class="comment">/*      Scan the file from the beginning, replacing the ``current       */</font>
00392 <font class="comment">/*      record'' in our structure with the one that is found.           */</font>
00393 <font class="comment">/* -------------------------------------------------------------------- */</font>
00394     VSIRewind( psTable-&gt;fp );
00395     CPLReadLine( psTable-&gt;fp );         <font class="comment">/* throw away the header line */</font>
00396     
00397     CSLDestroy( psTable-&gt;papszRecFields );
00398     psTable-&gt;papszRecFields =
00399         CSVScanLines( psTable-&gt;fp, iKeyField, pszValue, eCriteria );
00400 
00401     <font class="keywordflow">return</font>( psTable-&gt;papszRecFields );
00402 }
00403 
00404 <font class="comment">/************************************************************************/</font>
00405 <font class="comment">/*                           CPLGetFieldId()                            */</font>
00406 <font class="comment">/*                                                                      */</font>
00407 <font class="comment">/*      Read the first record of a CSV file (rewinding to be sure),     */</font>
00408 <font class="comment">/*      and find the field with the indicated name.  Returns -1 if      */</font>
00409 <font class="comment">/*      it fails to find the field name.  Comparison is case            */</font>
00410 <font class="comment">/*      insensitive, but otherwise exact.  After this function has      */</font>
00411 <font class="comment">/*      been called the file pointer will be positioned just after      */</font>
00412 <font class="comment">/*      the first record.                                               */</font>
00413 <font class="comment">/************************************************************************/</font>
00414 
00415 <font class="keywordtype">int</font> CSVGetFieldId( FILE * fp, <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFieldName )<font class="keyword"></font>
00416 <font class="keyword"></font>
00417 <font class="keyword"></font>{
00418     <font class="keywordtype">char</font>        **papszFields;
00419     <font class="keywordtype">int</font>         i;
00420     
00421     CPLAssert( fp != NULL &amp;&amp; pszFieldName != NULL );
00422 
00423     VSIRewind( fp );
00424 
00425     papszFields = CSVReadParseLine( fp );
00426     <font class="keywordflow">for</font>( i = 0; papszFields != NULL &amp;&amp; papszFields[i] != NULL; i++ )
00427     {
00428         <font class="keywordflow">if</font>( EQUAL(papszFields[i],pszFieldName) )
00429         {
00430             CSLDestroy( papszFields );
00431             <font class="keywordflow">return</font> i;
00432         }
00433     }
00434 
00435     CSLDestroy( papszFields );
00436 
00437     <font class="keywordflow">return</font> -1;
00438 }
00439 
00440 <font class="comment">/************************************************************************/</font>
00441 <font class="comment">/*                         CSVGetFileFieldId()                          */</font>
00442 <font class="comment">/*                                                                      */</font>
00443 <font class="comment">/*      Same as CPLGetFieldId(), except that we get the file based      */</font>
00444 <font class="comment">/*      on filename, rather than having an existing handle.             */</font>
00445 <font class="comment">/************************************************************************/</font>
00446 
00447 <font class="keywordtype">int</font> CSVGetFileFieldId( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFilename, <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFieldName )<font class="keyword"></font>
00448 <font class="keyword"></font>
00449 <font class="keyword"></font>{
00450     CSVTable    *psTable;
00451     <font class="keywordtype">int</font>         i;
00452     
00453 <font class="comment">/* -------------------------------------------------------------------- */</font>
00454 <font class="comment">/*      Get access to the table.                                        */</font>
00455 <font class="comment">/* -------------------------------------------------------------------- */</font>
00456     CPLAssert( pszFilename != NULL );
00457 
00458     psTable = CSVAccess( pszFilename );
00459     <font class="keywordflow">if</font>( psTable == NULL )
00460         <font class="keywordflow">return</font> -1;
00461 
00462 <font class="comment">/* -------------------------------------------------------------------- */</font>
00463 <font class="comment">/*      Find the requested field.                                       */</font>
00464 <font class="comment">/* -------------------------------------------------------------------- */</font>
00465     <font class="keywordflow">for</font>( i = 0;
00466          psTable-&gt;papszFieldNames != NULL
00467              &amp;&amp; psTable-&gt;papszFieldNames[i] != NULL;
00468          i++ )
00469     {
00470         <font class="keywordflow">if</font>( EQUAL(psTable-&gt;papszFieldNames[i],pszFieldName) )
00471         {
00472             <font class="keywordflow">return</font> i;
00473         }
00474     }
00475 
00476     <font class="keywordflow">return</font> -1;
00477 }
00478 
00479 
00480 <font class="comment">/************************************************************************/</font>
00481 <font class="comment">/*                         CSVScanFileByName()                          */</font>
00482 <font class="comment">/*                                                                      */</font>
00483 <font class="comment">/*      Same as CSVScanFile(), but using a field name instead of a      */</font>
00484 <font class="comment">/*      field number.                                                   */</font>
00485 <font class="comment">/************************************************************************/</font>
00486 
00487 <font class="keywordtype">char</font> **CSVScanFileByName( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFilename,
00488                           <font class="keyword">const</font> <font class="keywordtype">char</font> * pszKeyFieldName,
00489                           <font class="keyword">const</font> <font class="keywordtype">char</font> * pszValue, CSVCompareCriteria eCriteria )<font class="keyword"></font>
00490 <font class="keyword"></font>
00491 <font class="keyword"></font>{
00492     <font class="keywordtype">int</font>         iKeyField;
00493 
00494     iKeyField = CSVGetFileFieldId( pszFilename, pszKeyFieldName );
00495     <font class="keywordflow">if</font>( iKeyField == -1 )
00496         <font class="keywordflow">return</font> NULL;
00497 
00498     <font class="keywordflow">return</font>( CSVScanFile( pszFilename, iKeyField, pszValue, eCriteria ) );
00499 }
00500 
00501 <font class="comment">/************************************************************************/</font>
00502 <font class="comment">/*                            CSVGetField()                             */</font>
00503 <font class="comment">/*                                                                      */</font>
00504 <font class="comment">/*      The all-in-one function to fetch a particular field value       */</font>
00505 <font class="comment">/*      from a CSV file.  Note this function will return an empty       */</font>
00506 <font class="comment">/*      string, rather than NULL if it fails to find the desired        */</font>
00507 <font class="comment">/*      value for some reason.  The caller can't establish that the     */</font>
00508 <font class="comment">/*      fetch failed.                                                   */</font>
00509 <font class="comment">/************************************************************************/</font>
00510 
00511 <font class="keyword">const</font> <font class="keywordtype">char</font> *CSVGetField( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFilename,
00512                          <font class="keyword">const</font> <font class="keywordtype">char</font> * pszKeyFieldName,
00513                          <font class="keyword">const</font> <font class="keywordtype">char</font> * pszKeyFieldValue,
00514                          CSVCompareCriteria eCriteria,
00515                          <font class="keyword">const</font> <font class="keywordtype">char</font> * pszTargetField )<font class="keyword"></font>
00516 <font class="keyword"></font>
00517 <font class="keyword"></font>{
00518     CSVTable    *psTable;
00519     <font class="keywordtype">char</font>        **papszRecord;
00520     <font class="keywordtype">int</font>         iTargetField;
00521     
00522 <font class="comment">/* -------------------------------------------------------------------- */</font>
00523 <font class="comment">/*      Find the table.                                                 */</font>
00524 <font class="comment">/* -------------------------------------------------------------------- */</font>
00525     psTable = CSVAccess( pszFilename );
00526     <font class="keywordflow">if</font>( psTable == NULL )
00527         <font class="keywordflow">return</font> <font class="stringliteral">""</font>;
00528 
00529 <font class="comment">/* -------------------------------------------------------------------- */</font>
00530 <font class="comment">/*      Find the correct record.                                        */</font>
00531 <font class="comment">/* -------------------------------------------------------------------- */</font>
00532     papszRecord = CSVScanFileByName( pszFilename, pszKeyFieldName,
00533                                      pszKeyFieldValue, eCriteria );
00534 
00535     <font class="keywordflow">if</font>( papszRecord == NULL )
00536         <font class="keywordflow">return</font> <font class="stringliteral">""</font>;
00537 
00538 <font class="comment">/* -------------------------------------------------------------------- */</font>
00539 <font class="comment">/*      Figure out which field we want out of this.                     */</font>
00540 <font class="comment">/* -------------------------------------------------------------------- */</font>
00541     iTargetField = CSVGetFileFieldId( pszFilename, pszTargetField );
00542     <font class="keywordflow">if</font>( iTargetField &lt; 0 )
00543         <font class="keywordflow">return</font> <font class="stringliteral">""</font>;
00544 
00545     <font class="keywordflow">if</font>( iTargetField &gt;= CSLCount( papszRecord ) )
00546         <font class="keywordflow">return</font> <font class="stringliteral">""</font>;
00547 
00548     <font class="keywordflow">return</font>( papszRecord[iTargetField] );
00549 }
00550 
00551 <font class="comment">/************************************************************************/</font>
00552 <font class="comment">/*                            CSVFilename()                             */</font>
00553 <font class="comment">/*                                                                      */</font>
00554 <font class="comment">/*      Return the full path to a particular CSV file.                  */</font>
00555 <font class="comment">/************************************************************************/</font>
00556 
00557 <font class="keyword">static</font> <font class="keyword">const</font> <font class="keywordtype">char</font> *(*pfnCSVFilenameHook)(<font class="keyword">const</font> <font class="keywordtype">char</font> *) = NULL;
00558 
00559 <font class="keyword">const</font> <font class="keywordtype">char</font> * CSVFilename( <font class="keyword">const</font> <font class="keywordtype">char</font> *pszBasename )<font class="keyword"></font>
00560 <font class="keyword"></font>
00561 <font class="keyword"></font>{
00562     <font class="keyword">static</font> <font class="keywordtype">char</font>         szPath[512];
00563 
00564     <font class="keywordflow">if</font>( pfnCSVFilenameHook == NULL )
00565     {
00566         FILE    *fp = NULL;
00567 
00568         <font class="keywordflow">if</font>( getenv(<font class="stringliteral">"GEOTIFF_CSV"</font>) != NULL )
00569         {
00570             sprintf( szPath, <font class="stringliteral">"%s/%s"</font>, getenv(<font class="stringliteral">"GEOTIFF_CSV"</font>), pszBasename );
00571         }
00572 <font class="preprocessor">#ifdef CSV_DATA_DIR</font>
00573 <font class="preprocessor"></font>        <font class="keywordflow">else</font> 
00574         {
00575             sprintf( szPath, <font class="stringliteral">"%s/%s"</font>, CSV_DATA_DIR, pszBasename );
00576         }
00577 <font class="preprocessor">#else</font>
00578 <font class="preprocessor"></font>        <font class="keywordflow">else</font> <font class="keywordflow">if</font>( (fp = fopen( <font class="stringliteral">"/usr/local/share/epsg/csv/horiz_cs.csv"</font>, <font class="stringliteral">"rt"</font> )) != NULL )
00579         {
00580             sprintf( szPath, <font class="stringliteral">"/usr/local/share/epsg/csv/%s"</font>, pszBasename );
00581         }
00582         <font class="keywordflow">else</font> <font class="keywordflow">if</font>( (fp = fopen( <font class="stringliteral">"csv/horiz_cs.csv"</font>, <font class="stringliteral">"rt"</font> )) != NULL )
00583         {
00584             sprintf( szPath, <font class="stringliteral">"csv/%s"</font>, pszBasename );
00585         }
00586         <font class="keywordflow">else</font> <font class="keywordflow">if</font>( (fp = fopen( <font class="stringliteral">"share/epsg_csv/horiz_cs.csv"</font>, <font class="stringliteral">"rt"</font> )) != NULL )
00587         {
00588             sprintf( szPath, <font class="stringliteral">"share/epsg_csv/%s"</font>, pszBasename );
00589         }
00590         <font class="keywordflow">else</font> <font class="keywordflow">if</font>( (fp = fopen( <font class="stringliteral">"/usr/share/epsg_csv/horiz_cs.csv"</font>, <font class="stringliteral">"rt"</font> )) != NULL )
00591         {
00592             sprintf( szPath, <font class="stringliteral">"/usr/share/epsg_csv/%s"</font>, pszBasename );
00593         }
00594         <font class="keywordflow">else</font>
00595         {
00596             sprintf( szPath, <font class="stringliteral">"/usr/local/share/epsg_csv/%s"</font>, pszBasename );
00597         }
00598 <font class="preprocessor">#endif</font>
00599 <font class="preprocessor"></font>
00600         <font class="keywordflow">if</font>( fp != NULL )
00601             fclose( fp );
00602         
00603         <font class="keywordflow">return</font>( szPath );
00604     }
00605     <font class="keywordflow">else</font>
00606         <font class="keywordflow">return</font>( pfnCSVFilenameHook( pszBasename ) );
00607 }
00608 
00609 <font class="comment">/************************************************************************/</font>
00610 <font class="comment">/*                         SetCSVFilenameHook()                         */</font>
00611 <font class="comment">/*                                                                      */</font>
00612 <font class="comment">/*      Applications can use this to set a function that will           */</font>
00613 <font class="comment">/*      massage CSV filenames.                                          */</font>
00614 <font class="comment">/************************************************************************/</font>
00615 
00660 <font class="keywordtype">void</font> SetCSVFilenameHook( <font class="keyword">const</font> <font class="keywordtype">char</font> *(*pfnNewHook)( <font class="keyword">const</font> <font class="keywordtype">char</font> * ) )
00661 
00662 {
00663     pfnCSVFilenameHook = pfnNewHook;
00664 }
</div></pre><hr><address><small>Generated at Sun Mar 4 23:32:44 2001 for libgeotiff by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3-20001105 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
