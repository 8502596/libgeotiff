<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cpl_serv.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3-20001105 on Sun Mar 4 23:32:44 2001 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>cpl_serv.c</h1><div class="fragment"><pre>00001 <font class="comment">/******************************************************************************</font>
00002 <font class="comment"> * Copyright (c) 1998, Frank Warmerdam</font>
00003 <font class="comment"> *</font>
00004 <font class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a</font>
00005 <font class="comment"> * copy of this software and associated documentation files (the "Software"),</font>
00006 <font class="comment"> * to deal in the Software without restriction, including without limitation</font>
00007 <font class="comment"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</font>
00008 <font class="comment"> * and/or sell copies of the Software, and to permit persons to whom the</font>
00009 <font class="comment"> * Software is furnished to do so, subject to the following conditions:</font>
00010 <font class="comment"> *</font>
00011 <font class="comment"> * The above copyright notice and this permission notice shall be included</font>
00012 <font class="comment"> * in all copies or substantial portions of the Software.</font>
00013 <font class="comment"> *</font>
00014 <font class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</font>
00015 <font class="comment"> * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</font>
00016 <font class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</font>
00017 <font class="comment"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</font>
00018 <font class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</font>
00019 <font class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</font>
00020 <font class="comment"> * DEALINGS IN THE SOFTWARE.</font>
00021 <font class="comment"> ******************************************************************************</font>
00022 <font class="comment"> *</font>
00023 <font class="comment"> * cpl_serv.c: Various Common Portability Library derived convenience functions</font>
00024 <font class="comment"> *</font>
00025 <font class="comment"> * $Log$
00025 <font class="comment"> * Revision 1.2  2001/03/05 04:58:33  warmerda
00025 <font class="comment"> * updated
00025 <font class="comment"> *</font>
00026 <font class="comment"> * Revision 1.5  2000/09/30 03:35:05  warmerda</font>
00027 <font class="comment"> * Fixed CPLReadLine() to use avoid calling VSIRealloc() on a NULL pointer.</font>
00028 <font class="comment"> *</font>
00029 <font class="comment"> * Revision 1.4  1999/06/25 04:35:26  warmerda</font>
00030 <font class="comment"> * Fixed to actually support long lines.</font>
00031 <font class="comment"> *</font>
00032 <font class="comment"> * Revision 1.3  1999/03/17 20:43:03  geotiff</font>
00033 <font class="comment"> * Avoid use of size_t keyword</font>
00034 <font class="comment"> *</font>
00035 <font class="comment"> * Revision 1.2  1999/03/10 18:22:39  geotiff</font>
00036 <font class="comment"> * Added string.h, fixed backslash escaping</font>
00037 <font class="comment"> *</font>
00038 <font class="comment"> * Revision 1.1  1999/03/09 15:57:04  geotiff</font>
00039 <font class="comment"> * New</font>
00040 <font class="comment"> *</font>
00041 <font class="comment"> */</font>
00042 
00043 <font class="preprocessor">#include "cpl_serv.h"</font>
00044 <font class="preprocessor">#include "geo_tiffp.h"</font>
00045 
00046 <font class="preprocessor">#ifdef HAVE_STRING_H</font>
00047 <font class="preprocessor"></font><font class="preprocessor">#  include &lt;string.h&gt;</font>
00048 <font class="preprocessor">#endif</font>
00049 <font class="preprocessor"></font><font class="preprocessor">#if defined(HAVE_STRINGS_H) &amp;&amp; !defined(HAVE_STRING_H)</font>
00050 <font class="preprocessor"></font><font class="preprocessor">#  include &lt;strings.h&gt;</font>
00051 <font class="preprocessor">#endif</font>
00052 <font class="preprocessor"></font>
00053 <font class="comment">/************************************************************************/</font>
00054 <font class="comment">/*                             CPLCalloc()                              */</font>
00055 <font class="comment">/************************************************************************/</font>
00056 
00057 <font class="keywordtype">void</font> *CPLCalloc( <font class="keywordtype">int</font> nCount, <font class="keywordtype">int</font> nSize )<font class="keyword"></font>
00058 <font class="keyword"></font>
00059 <font class="keyword"></font>{
00060     <font class="keywordtype">void</font>        *pReturn;
00061 
00062     <font class="keywordflow">if</font>( nSize == 0 )
00063         <font class="keywordflow">return</font> NULL;
00064     
00065     pReturn = VSICalloc( nCount, nSize );
00066     <font class="keywordflow">if</font>( pReturn == NULL )
00067     {
00068         CPLError( CE_Fatal, CPLE_OutOfMemory,
00069                   <font class="stringliteral">"CPLCalloc(): Out of memory allocating %d bytes.\n"</font>,
00070                   nSize * nCount );
00071     }
00072 
00073     <font class="keywordflow">return</font> pReturn;
00074 }
00075 
00076 <font class="comment">/************************************************************************/</font>
00077 <font class="comment">/*                             CPLMalloc()                              */</font>
00078 <font class="comment">/************************************************************************/</font>
00079 
00080 <font class="keywordtype">void</font> *CPLMalloc( <font class="keywordtype">int</font> nSize )<font class="keyword"></font>
00081 <font class="keyword"></font>
00082 <font class="keyword"></font>{
00083     <font class="keywordtype">void</font>        *pReturn;
00084 
00085     <font class="keywordflow">if</font>( nSize == 0 )
00086         <font class="keywordflow">return</font> NULL;
00087     
00088     pReturn = VSIMalloc( nSize );
00089     <font class="keywordflow">if</font>( pReturn == NULL )
00090     {
00091         CPLError( CE_Fatal, CPLE_OutOfMemory,
00092                   <font class="stringliteral">"CPLMalloc(): Out of memory allocating %d bytes.\n"</font>,
00093                   nSize );
00094     }
00095 
00096     <font class="keywordflow">return</font> pReturn;
00097 }
00098 
00099 <font class="comment">/************************************************************************/</font>
00100 <font class="comment">/*                             CPLRealloc()                             */</font>
00101 <font class="comment">/************************************************************************/</font>
00102 
00103 <font class="keywordtype">void</font> * CPLRealloc( <font class="keywordtype">void</font> * pData, <font class="keywordtype">int</font> nNewSize )<font class="keyword"></font>
00104 <font class="keyword"></font>
00105 <font class="keyword"></font>{
00106     <font class="keywordtype">void</font>        *pReturn;
00107 
00108     <font class="keywordflow">if</font>( pData == NULL )
00109         pReturn = VSIMalloc( nNewSize );
00110     <font class="keywordflow">else</font>
00111         pReturn = VSIRealloc( pData, nNewSize );
00112     
00113     <font class="keywordflow">if</font>( pReturn == NULL )
00114     {
00115         CPLError( CE_Fatal, CPLE_OutOfMemory,
00116                   <font class="stringliteral">"CPLRealloc(): Out of memory allocating %d bytes.\n"</font>,
00117                   nNewSize );
00118     }
00119 
00120     <font class="keywordflow">return</font> pReturn;
00121 }
00122 
00123 <font class="comment">/************************************************************************/</font>
00124 <font class="comment">/*                             CPLStrdup()                              */</font>
00125 <font class="comment">/************************************************************************/</font>
00126 
00127 <font class="keywordtype">char</font> *CPLStrdup( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszString )<font class="keyword"></font>
00128 <font class="keyword"></font>
00129 <font class="keyword"></font>{
00130     <font class="keywordtype">char</font>        *pszReturn;
00131 
00132     <font class="keywordflow">if</font>( pszString == NULL )
00133         pszString = <font class="stringliteral">""</font>;
00134 
00135     pszReturn = VSIMalloc( strlen(pszString)+1 );
00136         
00137     <font class="keywordflow">if</font>( pszReturn == NULL )
00138     {
00139         CPLError( CE_Fatal, CPLE_OutOfMemory,
00140                   <font class="stringliteral">"CPLStrdup(): Out of memory allocating %d bytes.\n"</font>,
00141                   strlen(pszString) );
00142         
00143     }
00144 
00145     strcpy( pszReturn, pszString );
00146     
00147     <font class="keywordflow">return</font>( pszReturn );
00148 }
00149 
00150 <font class="comment">/************************************************************************/</font>
00151 <font class="comment">/*                            CPLReadLine()                             */</font>
00152 <font class="comment">/*                                                                      */</font>
00153 <font class="comment">/*      Read a line of text from the given file handle, taking care     */</font>
00154 <font class="comment">/*      to capture CR and/or LF and strip off ... equivelent of         */</font>
00155 <font class="comment">/*      DKReadLine().  Pointer to an internal buffer is returned.       */</font>
00156 <font class="comment">/*      The application shouldn't free it, or depend on it's value      */</font>
00157 <font class="comment">/*      past the next call to CPLReadLine()                             */</font>
00158 <font class="comment">/************************************************************************/</font>
00159 
00160 <font class="keyword">const</font> <font class="keywordtype">char</font> *CPLReadLine( FILE * fp )<font class="keyword"></font>
00161 <font class="keyword"></font>
00162 <font class="keyword"></font>{
00163     <font class="keyword">static</font> <font class="keywordtype">char</font> *pszRLBuffer = NULL;
00164     <font class="keyword">static</font> <font class="keywordtype">int</font>  nRLBufferSize = 0;
00165     <font class="keywordtype">int</font>         nLength, nReadSoFar = 0;
00166 
00167 <font class="comment">/* -------------------------------------------------------------------- */</font>
00168 <font class="comment">/*      Cleanup case.                                                   */</font>
00169 <font class="comment">/* -------------------------------------------------------------------- */</font>
00170     <font class="keywordflow">if</font>( fp == NULL )
00171     {
00172         CPLFree( pszRLBuffer );
00173         nRLBufferSize = 0;
00174         <font class="keywordflow">return</font> NULL;
00175     }
00176 
00177 <font class="comment">/* -------------------------------------------------------------------- */</font>
00178 <font class="comment">/*      Loop reading chunks of the line till we get to the end of       */</font>
00179 <font class="comment">/*      the line.                                                       */</font>
00180 <font class="comment">/* -------------------------------------------------------------------- */</font>
00181     <font class="keywordflow">do</font> {
00182 <font class="comment">/* -------------------------------------------------------------------- */</font>
00183 <font class="comment">/*      Grow the working buffer if we have it nearly full.  Fail out    */</font>
00184 <font class="comment">/*      of read line if we can't reallocate it big enough (for          */</font>
00185 <font class="comment">/*      instance for a _very large_ file with no newlines).             */</font>
00186 <font class="comment">/* -------------------------------------------------------------------- */</font>
00187         <font class="keywordflow">if</font>( nRLBufferSize-nReadSoFar &lt; 128 )
00188         {
00189             nRLBufferSize = nRLBufferSize*2 + 128;
00190             <font class="keywordflow">if</font>( pszRLBuffer == NULL )
00191                 pszRLBuffer = (<font class="keywordtype">char</font> *) VSIMalloc(nRLBufferSize);
00192             <font class="keywordflow">else</font>
00193                 pszRLBuffer = (<font class="keywordtype">char</font> *) VSIRealloc(pszRLBuffer, nRLBufferSize);
00194             <font class="keywordflow">if</font>( pszRLBuffer == NULL )
00195             {
00196                 nRLBufferSize = 0;
00197                 <font class="keywordflow">return</font> NULL;
00198             }
00199         }
00200 
00201 <font class="comment">/* -------------------------------------------------------------------- */</font>
00202 <font class="comment">/*      Do the actual read.                                             */</font>
00203 <font class="comment">/* -------------------------------------------------------------------- */</font>
00204         <font class="keywordflow">if</font>( VSIFGets( pszRLBuffer+nReadSoFar, nRLBufferSize-nReadSoFar, fp )
00205             == NULL )
00206         {
00207             CPLFree( pszRLBuffer );
00208             nRLBufferSize = 0;
00209 
00210             <font class="keywordflow">return</font> NULL;
00211         }
00212 
00213         nReadSoFar = strlen(pszRLBuffer);
00214 
00215     } <font class="keywordflow">while</font>( nReadSoFar == nRLBufferSize - 1
00216              &amp;&amp; pszRLBuffer[nRLBufferSize-2] != 13
00217              &amp;&amp; pszRLBuffer[nRLBufferSize-2] != 10 );
00218 
00219 <font class="comment">/* -------------------------------------------------------------------- */</font>
00220 <font class="comment">/*      Clear CR and LF off the end.                                    */</font>
00221 <font class="comment">/* -------------------------------------------------------------------- */</font>
00222     nLength = strlen(pszRLBuffer);
00223     <font class="keywordflow">if</font>( nLength &gt; 0
00224         &amp;&amp; (pszRLBuffer[nLength-1] == 10 || pszRLBuffer[nLength-1] == 13) )
00225     {
00226         pszRLBuffer[--nLength] = <font class="charliteral">'\0'</font>;
00227     }
00228     
00229     <font class="keywordflow">if</font>( nLength &gt; 0
00230         &amp;&amp; (pszRLBuffer[nLength-1] == 10 || pszRLBuffer[nLength-1] == 13) )
00231     {
00232         pszRLBuffer[--nLength] = <font class="charliteral">'\0'</font>;
00233     }
00234 
00235     <font class="keywordflow">return</font>( pszRLBuffer );
00236 }
00237 
00238 
00239 <font class="comment">/*=====================================================================</font>
00240 <font class="comment">                    StringList manipulation functions.</font>
00241 <font class="comment"> =====================================================================*/</font>
00242 
00243 <font class="comment">/**********************************************************************</font>
00244 <font class="comment"> *                       CSLAddString()</font>
00245 <font class="comment"> *</font>
00246 <font class="comment"> * Append a string to a StringList and return a pointer to the modified</font>
00247 <font class="comment"> * StringList.</font>
00248 <font class="comment"> * If the input StringList is NULL, then a new StringList is created.</font>
00249 <font class="comment"> **********************************************************************/</font>
00250 <font class="keywordtype">char</font> **CSLAddString(<font class="keywordtype">char</font> **papszStrList, <font class="keyword">const</font> <font class="keywordtype">char</font> *pszNewString)<font class="keyword"></font>
00251 <font class="keyword"></font>{
00252     <font class="keywordtype">int</font> nItems=0;
00253 
00254     <font class="keywordflow">if</font> (pszNewString == NULL)
00255         <font class="keywordflow">return</font> papszStrList;    <font class="comment">/* Nothing to do!*/</font>
00256 
00257     <font class="comment">/* Allocate room for the new string */</font>
00258     <font class="keywordflow">if</font> (papszStrList == NULL)
00259         papszStrList = (<font class="keywordtype">char</font>**) CPLCalloc(2,<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>*));
00260     <font class="keywordflow">else</font>
00261     {
00262         nItems = CSLCount(papszStrList);
00263         papszStrList = (<font class="keywordtype">char</font>**)CPLRealloc(papszStrList, 
00264                                           (nItems+2)*<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>*));
00265     }
00266 
00267     <font class="comment">/* Copy the string in the list */</font>
00268     papszStrList[nItems] = CPLStrdup(pszNewString);
00269     papszStrList[nItems+1] = NULL;
00270 
00271     <font class="keywordflow">return</font> papszStrList;
00272 }
00273 
00274 <font class="comment">/**********************************************************************</font>
00275 <font class="comment"> *                       CSLCount()</font>
00276 <font class="comment"> *</font>
00277 <font class="comment"> * Return the number of lines in a Stringlist.</font>
00278 <font class="comment"> **********************************************************************/</font>
00279 <font class="keywordtype">int</font> CSLCount(<font class="keywordtype">char</font> **papszStrList)<font class="keyword"></font>
00280 <font class="keyword"></font>{
00281     <font class="keywordtype">int</font> nItems=0;
00282 
00283     <font class="keywordflow">if</font> (papszStrList)
00284     {
00285         <font class="keywordflow">while</font>(*papszStrList != NULL)
00286         {
00287             nItems++;
00288             papszStrList++;
00289         }
00290     }
00291 
00292     <font class="keywordflow">return</font> nItems;
00293 }
00294 
00295 
00296 <font class="comment">/************************************************************************/</font>
00297 <font class="comment">/*                            CSLGetField()                             */</font>
00298 <font class="comment">/*                                                                      */</font>
00299 <font class="comment">/*      Fetches the indicated field, being careful not to crash if      */</font>
00300 <font class="comment">/*      the field doesn't exist within this string list.  The           */</font>
00301 <font class="comment">/*      returned pointer should not be freed, and doesn't               */</font>
00302 <font class="comment">/*      necessarily last long.                                          */</font>
00303 <font class="comment">/************************************************************************/</font>
00304 
00305 <font class="keyword">const</font> <font class="keywordtype">char</font> * CSLGetField( <font class="keywordtype">char</font> ** papszStrList, <font class="keywordtype">int</font> iField )<font class="keyword"></font>
00306 <font class="keyword"></font>
00307 <font class="keyword"></font>{
00308     <font class="keywordtype">int</font>         i;
00309 
00310     <font class="keywordflow">if</font>( papszStrList == NULL || iField &lt; 0 )
00311         <font class="keywordflow">return</font>( <font class="stringliteral">""</font> );
00312 
00313     <font class="keywordflow">for</font>( i = 0; i &lt; iField+1; i++ )
00314     {
00315         <font class="keywordflow">if</font>( papszStrList[i] == NULL )
00316             <font class="keywordflow">return</font> <font class="stringliteral">""</font>;
00317     }
00318 
00319     <font class="keywordflow">return</font>( papszStrList[iField] );
00320 }
00321 
00322 <font class="comment">/**********************************************************************</font>
00323 <font class="comment"> *                       CSLDestroy()</font>
00324 <font class="comment"> *</font>
00325 <font class="comment"> * Free all memory used by a StringList.</font>
00326 <font class="comment"> **********************************************************************/</font>
00327 <font class="keywordtype">void</font> CSLDestroy(<font class="keywordtype">char</font> **papszStrList)<font class="keyword"></font>
00328 <font class="keyword"></font>{
00329     <font class="keywordtype">char</font> **papszPtr;
00330 
00331     <font class="keywordflow">if</font> (papszStrList)
00332     {
00333         papszPtr = papszStrList;
00334         <font class="keywordflow">while</font>(*papszPtr != NULL)
00335         {
00336             CPLFree(*papszPtr);
00337             papszPtr++;
00338         }
00339 
00340         CPLFree(papszStrList);
00341     }
00342 }
00343 
00344 
00345 <font class="comment">/**********************************************************************</font>
00346 <font class="comment"> *                       CSLDuplicate()</font>
00347 <font class="comment"> *</font>
00348 <font class="comment"> * Allocate and return a copy of a StringList.</font>
00349 <font class="comment"> **********************************************************************/</font>
00350 <font class="keywordtype">char</font>    **CSLDuplicate(<font class="keywordtype">char</font> **papszStrList)<font class="keyword"></font>
00351 <font class="keyword"></font>{
00352     <font class="keywordtype">char</font> **papszNewList, **papszSrc, **papszDst;
00353     <font class="keywordtype">int</font>  nLines;
00354 
00355     nLines = CSLCount(papszStrList);
00356 
00357     <font class="keywordflow">if</font> (nLines == 0)
00358         <font class="keywordflow">return</font> NULL;
00359 
00360     papszNewList = (<font class="keywordtype">char</font> **)CPLMalloc((nLines+1)*<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>*));
00361     papszSrc = papszStrList;
00362     papszDst = papszNewList;
00363 
00364     <font class="keywordflow">while</font>(*papszSrc != NULL)
00365     {
00366         *papszDst = CPLStrdup(*papszSrc);
00367 
00368         papszSrc++;
00369         papszDst++;
00370     }
00371     *papszDst = NULL;
00372 
00373     <font class="keywordflow">return</font> papszNewList;
00374 }
00375 
00376 <font class="comment">/**********************************************************************</font>
00377 <font class="comment"> *                       CSLTokenizeString()</font>
00378 <font class="comment"> *</font>
00379 <font class="comment"> * Tokenizes a string and returns a StringList with one string for</font>
00380 <font class="comment"> * each token.</font>
00381 <font class="comment"> **********************************************************************/</font>
00382 <font class="keywordtype">char</font>    **CSLTokenizeString( <font class="keyword">const</font> <font class="keywordtype">char</font> *pszString )<font class="keyword"></font>
00383 <font class="keyword"></font>{
00384     <font class="keywordflow">return</font> CSLTokenizeStringComplex( pszString, <font class="stringliteral">" "</font>, TRUE, FALSE );
00385 }
00386 
00387 <font class="comment">/************************************************************************/</font>
00388 <font class="comment">/*                      CSLTokenizeStringComplex()                      */</font>
00389 <font class="comment">/*                                                                      */</font>
00390 <font class="comment">/*      The ultimate tokenizer?                                         */</font>
00391 <font class="comment">/************************************************************************/</font>
00392 
00393 <font class="keywordtype">char</font> ** CSLTokenizeStringComplex( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszString,
00394                                   <font class="keyword">const</font> <font class="keywordtype">char</font> * pszDelimiters,
00395                                   <font class="keywordtype">int</font> bHonourStrings, <font class="keywordtype">int</font> bAllowEmptyTokens )<font class="keyword"></font>
00396 <font class="keyword"></font>
00397 <font class="keyword"></font>{
00398     <font class="keywordtype">char</font>        **papszRetList = NULL;
00399     <font class="keywordtype">char</font>        *pszToken;
00400     <font class="keywordtype">int</font>         nTokenMax, nTokenLen;
00401 
00402     pszToken = (<font class="keywordtype">char</font> *) CPLCalloc(10,1);
00403     nTokenMax = 10;
00404     
00405     <font class="keywordflow">while</font>( pszString != NULL &amp;&amp; *pszString != <font class="charliteral">'\0'</font> )
00406     {
00407         <font class="keywordtype">int</font>     bInString = FALSE;
00408 
00409         nTokenLen = 0;
00410         
00411         <font class="comment">/* Try to find the next delimeter, marking end of token */</font>
00412         <font class="keywordflow">for</font>( ; *pszString != <font class="charliteral">'\0'</font>; pszString++ )
00413         {
00414 
00415             <font class="comment">/* End if this is a delimeter skip it and break. */</font>
00416             <font class="keywordflow">if</font>( !bInString &amp;&amp; strchr(pszDelimiters, *pszString) != NULL )
00417             {
00418                 pszString++;
00419                 <font class="keywordflow">break</font>;
00420             }
00421             
00422             <font class="comment">/* If this is a quote, and we are honouring constant</font>
00423 <font class="comment">               strings, then process the constant strings, with out delim</font>
00424 <font class="comment">               but don't copy over the quotes */</font>
00425             <font class="keywordflow">if</font>( bHonourStrings &amp;&amp; *pszString == <font class="charliteral">'"'</font> )
00426             {
00427                 <font class="keywordflow">if</font>( bInString )
00428                 {
00429                     bInString = FALSE;
00430                     <font class="keywordflow">continue</font>;
00431                 }
00432                 <font class="keywordflow">else</font>
00433                 {
00434                     bInString = TRUE;
00435                     <font class="keywordflow">continue</font>;
00436                 }
00437             }
00438 
00439             <font class="comment">/* Within string constants we allow for escaped quotes, but</font>
00440 <font class="comment">               in processing them we will unescape the quotes */</font>
00441             <font class="keywordflow">if</font>( bInString &amp;&amp; pszString[0] == <font class="charliteral">'\\'</font> &amp;&amp; pszString[1] == <font class="charliteral">'"'</font> )
00442             {
00443                 pszString++;
00444             }
00445 
00446             <font class="comment">/* Within string constants a \\ sequence reduces to \ */</font>
00447             <font class="keywordflow">else</font> <font class="keywordflow">if</font>( bInString
00448                      &amp;&amp; pszString[0] == <font class="charliteral">'\\'</font> &amp;&amp; pszString[1] == <font class="charliteral">'\\'</font> )
00449             {
00450                 pszString++;
00451             }
00452 
00453             <font class="keywordflow">if</font>( nTokenLen &gt;= nTokenMax-1 )
00454             {
00455                 nTokenMax = nTokenMax * 2 + 10;
00456                 pszToken = (<font class="keywordtype">char</font> *) CPLRealloc( pszToken, nTokenMax );
00457             }
00458 
00459             pszToken[nTokenLen] = *pszString;
00460             nTokenLen++;
00461         }
00462 
00463         pszToken[nTokenLen] = <font class="charliteral">'\0'</font>;
00464 
00465         <font class="keywordflow">if</font>( pszToken[0] != <font class="charliteral">'\0'</font> || bAllowEmptyTokens )
00466         {
00467             papszRetList = CSLAddString( papszRetList, pszToken );
00468         }
00469     }
00470 
00471     <font class="keywordflow">if</font>( papszRetList == NULL )
00472         papszRetList = (<font class="keywordtype">char</font> **) CPLCalloc(<font class="keyword">sizeof</font>(<font class="keywordtype">char</font> *),1);
00473 
00474     CPLFree( pszToken );
00475 
00476     <font class="keywordflow">return</font> papszRetList;
00477 }
00478 
00479 <font class="comment">/* static buffer to store the last error message.  We'll assume that error</font>
00480 <font class="comment"> * messages cannot be longer than 2000 chars... which is quite reasonable</font>
00481 <font class="comment"> * (that's 25 lines of 80 chars!!!)</font>
00482 <font class="comment"> */</font>
00483 <font class="keyword">static</font> <font class="keywordtype">char</font> gszCPLLastErrMsg[2000] = <font class="stringliteral">""</font>;
00484 <font class="keyword">static</font> <font class="keywordtype">int</font>  gnCPLLastErrNo = 0;
00485 
00486 <font class="keyword">static</font> void (*gpfnCPLErrorHandler)(CPLErr, <font class="keywordtype">int</font>, <font class="keyword">const</font> <font class="keywordtype">char</font> *) = NULL;
00487 
00488 <font class="comment">/**********************************************************************</font>
00489 <font class="comment"> *                          CPLError()</font>
00490 <font class="comment"> *</font>
00491 <font class="comment"> * This function records an error code and displays the error message</font>
00492 <font class="comment"> * to stderr.</font>
00493 <font class="comment"> *</font>
00494 <font class="comment"> * The error code can be accessed later using CPLGetLastErrNo()</font>
00495 <font class="comment"> **********************************************************************/</font>
00496 <font class="keywordtype">void</font>    CPLError(CPLErr eErrClass, <font class="keywordtype">int</font> err_no, <font class="keyword">const</font> <font class="keywordtype">char</font> *fmt, ...)<font class="keyword"></font>
00497 <font class="keyword"></font>{
00498     va_list args;
00499 
00500     <font class="comment">/* Expand the error message </font>
00501 <font class="comment">     */</font>
00502     va_start(args, fmt);
00503     vsprintf(gszCPLLastErrMsg, fmt, args);
00504     va_end(args);
00505 
00506     <font class="comment">/* If the user provided his own error handling function, then call</font>
00507 <font class="comment">     * it, otherwise print the error to stderr and return.</font>
00508 <font class="comment">     */</font>
00509     gnCPLLastErrNo = err_no;
00510 
00511     <font class="keywordflow">if</font> (gpfnCPLErrorHandler != NULL)
00512     {
00513         gpfnCPLErrorHandler(eErrClass, err_no, gszCPLLastErrMsg);
00514     }
00515     <font class="keywordflow">else</font>
00516     {
00517         fprintf(stderr, <font class="stringliteral">"ERROR %d: %s\n"</font>, gnCPLLastErrNo, gszCPLLastErrMsg);
00518     }
00519 
00520     <font class="keywordflow">if</font>( eErrClass == CE_Fatal )
00521         abort();
00522 }
00523 
00524 <font class="comment">/**********************************************************************</font>
00525 <font class="comment"> *                          CPLErrorReset()</font>
00526 <font class="comment"> *</font>
00527 <font class="comment"> * Erase any traces of previous errors.</font>
00528 <font class="comment"> **********************************************************************/</font>
00529 <font class="keywordtype">void</font>    CPLErrorReset()<font class="keyword"></font>
00530 <font class="keyword"></font>{
00531     gnCPLLastErrNo = 0;
00532     gszCPLLastErrMsg[0] = <font class="charliteral">'\0'</font>;
00533 }
00534 
00535 
00536 <font class="comment">/**********************************************************************</font>
00537 <font class="comment"> *                          CPLGetLastErrorNo()</font>
00538 <font class="comment"> *</font>
00539 <font class="comment"> **********************************************************************/</font>
00540 <font class="keywordtype">int</font>     CPLGetLastErrorNo()<font class="keyword"></font>
00541 <font class="keyword"></font>{
00542     <font class="keywordflow">return</font> gnCPLLastErrNo;
00543 }
00544 
00545 <font class="comment">/**********************************************************************</font>
00546 <font class="comment"> *                          CPLGetLastErrorMsg()</font>
00547 <font class="comment"> *</font>
00548 <font class="comment"> **********************************************************************/</font>
00549 <font class="keyword">const</font> <font class="keywordtype">char</font>* CPLGetLastErrorMsg()<font class="keyword"></font>
00550 <font class="keyword"></font>{
00551     <font class="keywordflow">return</font> gszCPLLastErrMsg;
00552 }
00553 
00554 <font class="comment">/**********************************************************************</font>
00555 <font class="comment"> *                          CPLSetErrorHandler()</font>
00556 <font class="comment"> *</font>
00557 <font class="comment"> * Allow the library's user to specify his own error handler function.</font>
00558 <font class="comment"> *</font>
00559 <font class="comment"> * A valid error handler is a C function with the following prototype:</font>
00560 <font class="comment"> *</font>
00561 <font class="comment"> *     void MyErrorHandler(int errno, const char *msg)</font>
00562 <font class="comment"> *</font>
00563 <font class="comment"> * Pass NULL to come back to the default behavior.</font>
00564 <font class="comment"> **********************************************************************/</font>
00565 
00566 <font class="keywordtype">void</font>     CPLSetErrorHandler(<font class="keywordtype">void</font> (*pfnErrorHandler)(CPLErr, <font class="keywordtype">int</font>, <font class="keyword">const</font> <font class="keywordtype">char</font> *))
00567 {
00568     gpfnCPLErrorHandler = pfnErrorHandler;
00569 }
00570 
00571 <font class="comment">/************************************************************************/</font>
00572 <font class="comment">/*                             _CPLAssert()                             */</font>
00573 <font class="comment">/*                                                                      */</font>
00574 <font class="comment">/*      This function is called only when an assertion fails.           */</font>
00575 <font class="comment">/************************************************************************/</font>
00576 
00577 <font class="keywordtype">void</font> _CPLAssert( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszExpression, <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFile,
00578                  <font class="keywordtype">int</font> iLine )<font class="keyword"></font>
00579 <font class="keyword"></font>
00580 <font class="keyword"></font>{
00581     CPLError( CE_Fatal, CPLE_AssertionFailed,
00582               <font class="stringliteral">"Assertion `%s' failed\n"</font>
00583               <font class="stringliteral">"in file `%s', line %d\n"</font>,
00584               pszExpression, pszFile, iLine );
00585 }
</div></pre><hr><address><small>Generated at Sun Mar 4 23:32:44 2001 for libgeotiff by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3-20001105 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
