<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cpl_serv.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3-20001105 on Sun Mar 4 22:25:48 2001 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>cpl_serv.c</h1><div class="fragment"><pre>00001 <font class="comment">/******************************************************************************</font>
00002 <font class="comment"> * Copyright (c) 1998, Frank Warmerdam</font>
00003 <font class="comment"> *</font>
00004 <font class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a</font>
00005 <font class="comment"> * copy of this software and associated documentation files (the "Software"),</font>
00006 <font class="comment"> * to deal in the Software without restriction, including without limitation</font>
00007 <font class="comment"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</font>
00008 <font class="comment"> * and/or sell copies of the Software, and to permit persons to whom the</font>
00009 <font class="comment"> * Software is furnished to do so, subject to the following conditions:</font>
00010 <font class="comment"> *</font>
00011 <font class="comment"> * The above copyright notice and this permission notice shall be included</font>
00012 <font class="comment"> * in all copies or substantial portions of the Software.</font>
00013 <font class="comment"> *</font>
00014 <font class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</font>
00015 <font class="comment"> * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</font>
00016 <font class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</font>
00017 <font class="comment"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</font>
00018 <font class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</font>
00019 <font class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</font>
00020 <font class="comment"> * DEALINGS IN THE SOFTWARE.</font>
00021 <font class="comment"> ******************************************************************************</font>
00022 <font class="comment"> *</font>
00023 <font class="comment"> * cpl_serv.c: Various Common Portability Library derived convenience functions</font>
00024 <font class="comment"> *</font>
00025 <font class="comment"> * $Log$
00025 <font class="comment"> * Revision 1.1  2001/03/05 03:34:00  warmerda
00025 <font class="comment"> * New
00025 <font class="comment"> *</font>
00026 <font class="comment"> * Revision 1.5  2000/09/30 03:35:05  warmerda</font>
00027 <font class="comment"> * Fixed CPLReadLine() to use avoid calling VSIRealloc() on a NULL pointer.</font>
00028 <font class="comment"> *</font>
00029 <font class="comment"> * Revision 1.4  1999/06/25 04:35:26  warmerda</font>
00030 <font class="comment"> * Fixed to actually support long lines.</font>
00031 <font class="comment"> *</font>
00032 <font class="comment"> * Revision 1.3  1999/03/17 20:43:03  geotiff</font>
00033 <font class="comment"> * Avoid use of size_t keyword</font>
00034 <font class="comment"> *</font>
00035 <font class="comment"> * Revision 1.2  1999/03/10 18:22:39  geotiff</font>
00036 <font class="comment"> * Added string.h, fixed backslash escaping</font>
00037 <font class="comment"> *</font>
00038 <font class="comment"> * Revision 1.1  1999/03/09 15:57:04  geotiff</font>
00039 <font class="comment"> * New</font>
00040 <font class="comment"> *</font>
00041 <font class="comment"> */</font>
00042 
00043 <font class="preprocessor">#include "cpl_serv.h"</font>
00044 <font class="preprocessor">#include "geo_tiffp.h"</font>
00045 
00046 <font class="preprocessor">#ifdef HAVE_STRING_H</font>
00047 <font class="preprocessor"></font><font class="preprocessor">#  include &lt;string.h&gt;</font>
00048 <font class="preprocessor">#endif</font>
00049 <font class="preprocessor"></font><font class="preprocessor">#if defined(HAVE_STRINGS_H) &amp;&amp; !defined(HAVE_STRING_H)</font>
00050 <font class="preprocessor"></font><font class="preprocessor">#  include &lt;strings.h&gt;</font>
00051 <font class="preprocessor">#endif</font>
00052 <font class="preprocessor"></font>
00053 <font class="comment">/************************************************************************/</font>
00054 <font class="comment">/*                             CPLCalloc()                              */</font>
00055 <font class="comment">/************************************************************************/</font>
00056 
00057 <font class="keywordtype">void</font> *CPLCalloc( <font class="keywordtype">int</font> nCount, <font class="keywordtype">int</font> nSize )<font class="keyword"></font>
00058 <font class="keyword"></font>
00059 <font class="keyword"></font>{
00060     <font class="keywordtype">void</font>        *pReturn;
00061 
00062     <font class="keywordflow">if</font>( nSize == 0 )
00063         <font class="keywordflow">return</font> NULL;
00064     
00065     pReturn = VSICalloc( nCount, nSize );
00066     <font class="keywordflow">if</font>( pReturn == NULL )
00067     {
00068         CPLError( CE_Fatal, CPLE_OutOfMemory,
00069                   <font class="stringliteral">"CPLCalloc(): Out of memory allocating %d bytes.\n"</font>,
00070                   nSize * nCount );
00071     }
00072 
00073     <font class="keywordflow">return</font> pReturn;
00074 }
00075 
00076 <font class="comment">/************************************************************************/</font>
00077 <font class="comment">/*                             CPLMalloc()                              */</font>
00078 <font class="comment">/************************************************************************/</font>
00079 
00080 <font class="keywordtype">void</font> *CPLMalloc( <font class="keywordtype">int</font> nSize )<font class="keyword"></font>
00081 <font class="keyword"></font>
00082 <font class="keyword"></font>{
00083     <font class="keywordtype">void</font>        *pReturn;
00084 
00085     <font class="keywordflow">if</font>( nSize == 0 )
00086         <font class="keywordflow">return</font> NULL;
00087     
00088     pReturn = VSIMalloc( nSize );
00089     <font class="keywordflow">if</font>( pReturn == NULL )
00090     {
00091         CPLError( CE_Fatal, CPLE_OutOfMemory,
00092                   <font class="stringliteral">"CPLMalloc(): Out of memory allocating %d bytes.\n"</font>,
00093                   nSize );
00094     }
00095 
00096     <font class="keywordflow">return</font> pReturn;
00097 }
00098 
00099 <font class="comment">/************************************************************************/</font>
00100 <font class="comment">/*                             CPLRealloc()                             */</font>
00101 <font class="comment">/************************************************************************/</font>
00102 
00103 <font class="keywordtype">void</font> * CPLRealloc( <font class="keywordtype">void</font> * pData, <font class="keywordtype">int</font> nNewSize )<font class="keyword"></font>
00104 <font class="keyword"></font>
00105 <font class="keyword"></font>{
00106     <font class="keywordtype">void</font>        *pReturn;
00107 
00108     <font class="keywordflow">if</font>( pData == NULL )
00109         pReturn = VSIMalloc( nNewSize );
00110     <font class="keywordflow">else</font>
00111         pReturn = VSIRealloc( pData, nNewSize );
00112     
00113     <font class="keywordflow">if</font>( pReturn == NULL )
00114     {
00115         CPLError( CE_Fatal, CPLE_OutOfMemory,
00116                   <font class="stringliteral">"CPLRealloc(): Out of memory allocating %d bytes.\n"</font>,
00117                   nNewSize );
00118     }
00119 
00120     <font class="keywordflow">return</font> pReturn;
00121 }
00122 
00123 <font class="comment">/************************************************************************/</font>
00124 <font class="comment">/*                             CPLStrdup()                              */</font>
00125 <font class="comment">/************************************************************************/</font>
00126 
00127 <font class="keywordtype">char</font> *CPLStrdup( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszString )<font class="keyword"></font>
00128 <font class="keyword"></font>
00129 <font class="keyword"></font>{
00130     <font class="keywordtype">char</font>        *pszReturn;
00131 
00132     <font class="keywordflow">if</font>( pszString == NULL )
00133         pszString = <font class="stringliteral">""</font>;
00134 
00135     pszReturn = VSIMalloc( strlen(pszString)+1 );
00136         
00137     <font class="keywordflow">if</font>( pszReturn == NULL )
00138     {
00139         CPLError( CE_Fatal, CPLE_OutOfMemory,
00140                   <font class="stringliteral">"CPLStrdup(): Out of memory allocating %d bytes.\n"</font>,
00141                   strlen(pszString) );
00142         
00143     }
00144 
00145     strcpy( pszReturn, pszString );
00146     
00147     <font class="keywordflow">return</font>( pszReturn );
00148 }
00149 
00150 <font class="comment">/************************************************************************/</font>
00151 <font class="comment">/*                            CPLReadLine()                             */</font>
00152 <font class="comment">/*                                                                      */</font>
00153 <font class="comment">/*      Read a line of text from the given file handle, taking care     */</font>
00154 <font class="comment">/*      to capture CR and/or LF and strip off ... equivelent of         */</font>
00155 <font class="comment">/*      DKReadLine().  Pointer to an internal buffer is returned.       */</font>
00156 <font class="comment">/*      The application shouldn't free it, or depend on it's value      */</font>
00157 <font class="comment">/*      past the next call to CPLReadLine()                             */</font>
00158 <font class="comment">/************************************************************************/</font>
00159 
00160 <font class="keyword">const</font> <font class="keywordtype">char</font> *CPLReadLine( FILE * fp )<font class="keyword"></font>
00161 <font class="keyword"></font>
00162 <font class="keyword"></font>{
00163     <font class="keyword">static</font> <font class="keywordtype">char</font> *pszRLBuffer = NULL;
00164     <font class="keyword">static</font> <font class="keywordtype">int</font>  nRLBufferSize = 0;
00165     <font class="keywordtype">int</font>         nLength, nReadSoFar = 0;
00166 
00167 <font class="comment">/* -------------------------------------------------------------------- */</font>
00168 <font class="comment">/*      Loop reading chunks of the line till we get to the end of       */</font>
00169 <font class="comment">/*      the line.                                                       */</font>
00170 <font class="comment">/* -------------------------------------------------------------------- */</font>
00171     <font class="keywordflow">do</font> {
00172 <font class="comment">/* -------------------------------------------------------------------- */</font>
00173 <font class="comment">/*      Grow the working buffer if we have it nearly full.  Fail out    */</font>
00174 <font class="comment">/*      of read line if we can't reallocate it big enough (for          */</font>
00175 <font class="comment">/*      instance for a _very large_ file with no newlines).             */</font>
00176 <font class="comment">/* -------------------------------------------------------------------- */</font>
00177         <font class="keywordflow">if</font>( nRLBufferSize-nReadSoFar &lt; 128 )
00178         {
00179             nRLBufferSize = nRLBufferSize*2 + 128;
00180             <font class="keywordflow">if</font>( pszRLBuffer == NULL )
00181                 pszRLBuffer = (<font class="keywordtype">char</font> *) VSIMalloc(nRLBufferSize);
00182             <font class="keywordflow">else</font>
00183                 pszRLBuffer = (<font class="keywordtype">char</font> *) VSIRealloc(pszRLBuffer, nRLBufferSize);
00184             <font class="keywordflow">if</font>( pszRLBuffer == NULL )
00185             {
00186                 nRLBufferSize = 0;
00187                 <font class="keywordflow">return</font> NULL;
00188             }
00189         }
00190 
00191 <font class="comment">/* -------------------------------------------------------------------- */</font>
00192 <font class="comment">/*      Do the actual read.                                             */</font>
00193 <font class="comment">/* -------------------------------------------------------------------- */</font>
00194         <font class="keywordflow">if</font>( VSIFGets( pszRLBuffer+nReadSoFar, nRLBufferSize-nReadSoFar, fp )
00195             == NULL )
00196             <font class="keywordflow">return</font> NULL;
00197 
00198         nReadSoFar = strlen(pszRLBuffer);
00199 
00200     } <font class="keywordflow">while</font>( nReadSoFar == nRLBufferSize - 1
00201              &amp;&amp; pszRLBuffer[nRLBufferSize-2] != 13
00202              &amp;&amp; pszRLBuffer[nRLBufferSize-2] != 10 );
00203 
00204 <font class="comment">/* -------------------------------------------------------------------- */</font>
00205 <font class="comment">/*      Clear CR and LF off the end.                                    */</font>
00206 <font class="comment">/* -------------------------------------------------------------------- */</font>
00207     nLength = strlen(pszRLBuffer);
00208     <font class="keywordflow">if</font>( nLength &gt; 0
00209         &amp;&amp; (pszRLBuffer[nLength-1] == 10 || pszRLBuffer[nLength-1] == 13) )
00210     {
00211         pszRLBuffer[--nLength] = <font class="charliteral">'\0'</font>;
00212     }
00213     
00214     <font class="keywordflow">if</font>( nLength &gt; 0
00215         &amp;&amp; (pszRLBuffer[nLength-1] == 10 || pszRLBuffer[nLength-1] == 13) )
00216     {
00217         pszRLBuffer[--nLength] = <font class="charliteral">'\0'</font>;
00218     }
00219 
00220     <font class="keywordflow">return</font>( pszRLBuffer );
00221 }
00222 
00223 
00224 <font class="comment">/*=====================================================================</font>
00225 <font class="comment">                    StringList manipulation functions.</font>
00226 <font class="comment"> =====================================================================*/</font>
00227 
00228 <font class="comment">/**********************************************************************</font>
00229 <font class="comment"> *                       CSLAddString()</font>
00230 <font class="comment"> *</font>
00231 <font class="comment"> * Append a string to a StringList and return a pointer to the modified</font>
00232 <font class="comment"> * StringList.</font>
00233 <font class="comment"> * If the input StringList is NULL, then a new StringList is created.</font>
00234 <font class="comment"> **********************************************************************/</font>
00235 <font class="keywordtype">char</font> **CSLAddString(<font class="keywordtype">char</font> **papszStrList, <font class="keyword">const</font> <font class="keywordtype">char</font> *pszNewString)<font class="keyword"></font>
00236 <font class="keyword"></font>{
00237     <font class="keywordtype">int</font> nItems=0;
00238 
00239     <font class="keywordflow">if</font> (pszNewString == NULL)
00240         <font class="keywordflow">return</font> papszStrList;    <font class="comment">/* Nothing to do!*/</font>
00241 
00242     <font class="comment">/* Allocate room for the new string */</font>
00243     <font class="keywordflow">if</font> (papszStrList == NULL)
00244         papszStrList = (<font class="keywordtype">char</font>**) CPLCalloc(2,<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>*));
00245     <font class="keywordflow">else</font>
00246     {
00247         nItems = CSLCount(papszStrList);
00248         papszStrList = (<font class="keywordtype">char</font>**)CPLRealloc(papszStrList, 
00249                                           (nItems+2)*<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>*));
00250     }
00251 
00252     <font class="comment">/* Copy the string in the list */</font>
00253     papszStrList[nItems] = CPLStrdup(pszNewString);
00254     papszStrList[nItems+1] = NULL;
00255 
00256     <font class="keywordflow">return</font> papszStrList;
00257 }
00258 
00259 <font class="comment">/**********************************************************************</font>
00260 <font class="comment"> *                       CSLCount()</font>
00261 <font class="comment"> *</font>
00262 <font class="comment"> * Return the number of lines in a Stringlist.</font>
00263 <font class="comment"> **********************************************************************/</font>
00264 <font class="keywordtype">int</font> CSLCount(<font class="keywordtype">char</font> **papszStrList)<font class="keyword"></font>
00265 <font class="keyword"></font>{
00266     <font class="keywordtype">int</font> nItems=0;
00267 
00268     <font class="keywordflow">if</font> (papszStrList)
00269     {
00270         <font class="keywordflow">while</font>(*papszStrList != NULL)
00271         {
00272             nItems++;
00273             papszStrList++;
00274         }
00275     }
00276 
00277     <font class="keywordflow">return</font> nItems;
00278 }
00279 
00280 
00281 <font class="comment">/************************************************************************/</font>
00282 <font class="comment">/*                            CSLGetField()                             */</font>
00283 <font class="comment">/*                                                                      */</font>
00284 <font class="comment">/*      Fetches the indicated field, being careful not to crash if      */</font>
00285 <font class="comment">/*      the field doesn't exist within this string list.  The           */</font>
00286 <font class="comment">/*      returned pointer should not be freed, and doesn't               */</font>
00287 <font class="comment">/*      necessarily last long.                                          */</font>
00288 <font class="comment">/************************************************************************/</font>
00289 
00290 <font class="keyword">const</font> <font class="keywordtype">char</font> * CSLGetField( <font class="keywordtype">char</font> ** papszStrList, <font class="keywordtype">int</font> iField )<font class="keyword"></font>
00291 <font class="keyword"></font>
00292 <font class="keyword"></font>{
00293     <font class="keywordtype">int</font>         i;
00294 
00295     <font class="keywordflow">if</font>( papszStrList == NULL || iField &lt; 0 )
00296         <font class="keywordflow">return</font>( <font class="stringliteral">""</font> );
00297 
00298     <font class="keywordflow">for</font>( i = 0; i &lt; iField+1; i++ )
00299     {
00300         <font class="keywordflow">if</font>( papszStrList[i] == NULL )
00301             <font class="keywordflow">return</font> <font class="stringliteral">""</font>;
00302     }
00303 
00304     <font class="keywordflow">return</font>( papszStrList[iField] );
00305 }
00306 
00307 <font class="comment">/**********************************************************************</font>
00308 <font class="comment"> *                       CSLDestroy()</font>
00309 <font class="comment"> *</font>
00310 <font class="comment"> * Free all memory used by a StringList.</font>
00311 <font class="comment"> **********************************************************************/</font>
00312 <font class="keywordtype">void</font> CSLDestroy(<font class="keywordtype">char</font> **papszStrList)<font class="keyword"></font>
00313 <font class="keyword"></font>{
00314     <font class="keywordtype">char</font> **papszPtr;
00315 
00316     <font class="keywordflow">if</font> (papszStrList)
00317     {
00318         papszPtr = papszStrList;
00319         <font class="keywordflow">while</font>(*papszPtr != NULL)
00320         {
00321             CPLFree(*papszPtr);
00322             papszPtr++;
00323         }
00324 
00325         CPLFree(papszStrList);
00326     }
00327 }
00328 
00329 
00330 <font class="comment">/**********************************************************************</font>
00331 <font class="comment"> *                       CSLDuplicate()</font>
00332 <font class="comment"> *</font>
00333 <font class="comment"> * Allocate and return a copy of a StringList.</font>
00334 <font class="comment"> **********************************************************************/</font>
00335 <font class="keywordtype">char</font>    **CSLDuplicate(<font class="keywordtype">char</font> **papszStrList)<font class="keyword"></font>
00336 <font class="keyword"></font>{
00337     <font class="keywordtype">char</font> **papszNewList, **papszSrc, **papszDst;
00338     <font class="keywordtype">int</font>  nLines;
00339 
00340     nLines = CSLCount(papszStrList);
00341 
00342     <font class="keywordflow">if</font> (nLines == 0)
00343         <font class="keywordflow">return</font> NULL;
00344 
00345     papszNewList = (<font class="keywordtype">char</font> **)CPLMalloc((nLines+1)*<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>*));
00346     papszSrc = papszStrList;
00347     papszDst = papszNewList;
00348 
00349     <font class="keywordflow">while</font>(*papszSrc != NULL)
00350     {
00351         *papszDst = CPLStrdup(*papszSrc);
00352 
00353         papszSrc++;
00354         papszDst++;
00355     }
00356     *papszDst = NULL;
00357 
00358     <font class="keywordflow">return</font> papszNewList;
00359 }
00360 
00361 <font class="comment">/**********************************************************************</font>
00362 <font class="comment"> *                       CSLTokenizeString()</font>
00363 <font class="comment"> *</font>
00364 <font class="comment"> * Tokenizes a string and returns a StringList with one string for</font>
00365 <font class="comment"> * each token.</font>
00366 <font class="comment"> **********************************************************************/</font>
00367 <font class="keywordtype">char</font>    **CSLTokenizeString( <font class="keyword">const</font> <font class="keywordtype">char</font> *pszString )<font class="keyword"></font>
00368 <font class="keyword"></font>{
00369     <font class="keywordflow">return</font> CSLTokenizeStringComplex( pszString, <font class="stringliteral">" "</font>, TRUE, FALSE );
00370 }
00371 
00372 <font class="comment">/************************************************************************/</font>
00373 <font class="comment">/*                      CSLTokenizeStringComplex()                      */</font>
00374 <font class="comment">/*                                                                      */</font>
00375 <font class="comment">/*      The ultimate tokenizer?                                         */</font>
00376 <font class="comment">/************************************************************************/</font>
00377 
00378 <font class="keywordtype">char</font> ** CSLTokenizeStringComplex( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszString,
00379                                   <font class="keyword">const</font> <font class="keywordtype">char</font> * pszDelimiters,
00380                                   <font class="keywordtype">int</font> bHonourStrings, <font class="keywordtype">int</font> bAllowEmptyTokens )<font class="keyword"></font>
00381 <font class="keyword"></font>
00382 <font class="keyword"></font>{
00383     <font class="keywordtype">char</font>        **papszRetList = NULL;
00384     <font class="keywordtype">char</font>        *pszToken;
00385     <font class="keywordtype">int</font>         nTokenMax, nTokenLen;
00386 
00387     pszToken = (<font class="keywordtype">char</font> *) CPLCalloc(10,1);
00388     nTokenMax = 10;
00389     
00390     <font class="keywordflow">while</font>( pszString != NULL &amp;&amp; *pszString != <font class="charliteral">'\0'</font> )
00391     {
00392         <font class="keywordtype">int</font>     bInString = FALSE;
00393 
00394         nTokenLen = 0;
00395         
00396         <font class="comment">/* Try to find the next delimeter, marking end of token */</font>
00397         <font class="keywordflow">for</font>( ; *pszString != <font class="charliteral">'\0'</font>; pszString++ )
00398         {
00399 
00400             <font class="comment">/* End if this is a delimeter skip it and break. */</font>
00401             <font class="keywordflow">if</font>( !bInString &amp;&amp; strchr(pszDelimiters, *pszString) != NULL )
00402             {
00403                 pszString++;
00404                 <font class="keywordflow">break</font>;
00405             }
00406             
00407             <font class="comment">/* If this is a quote, and we are honouring constant</font>
00408 <font class="comment">               strings, then process the constant strings, with out delim</font>
00409 <font class="comment">               but don't copy over the quotes */</font>
00410             <font class="keywordflow">if</font>( bHonourStrings &amp;&amp; *pszString == <font class="charliteral">'"'</font> )
00411             {
00412                 <font class="keywordflow">if</font>( bInString )
00413                 {
00414                     bInString = FALSE;
00415                     <font class="keywordflow">continue</font>;
00416                 }
00417                 <font class="keywordflow">else</font>
00418                 {
00419                     bInString = TRUE;
00420                     <font class="keywordflow">continue</font>;
00421                 }
00422             }
00423 
00424             <font class="comment">/* Within string constants we allow for escaped quotes, but</font>
00425 <font class="comment">               in processing them we will unescape the quotes */</font>
00426             <font class="keywordflow">if</font>( bInString &amp;&amp; pszString[0] == <font class="charliteral">'\\'</font> &amp;&amp; pszString[1] == <font class="charliteral">'"'</font> )
00427             {
00428                 pszString++;
00429             }
00430 
00431             <font class="comment">/* Within string constants a \\ sequence reduces to \ */</font>
00432             <font class="keywordflow">else</font> <font class="keywordflow">if</font>( bInString
00433                      &amp;&amp; pszString[0] == <font class="charliteral">'\\'</font> &amp;&amp; pszString[1] == <font class="charliteral">'\\'</font> )
00434             {
00435                 pszString++;
00436             }
00437 
00438             <font class="keywordflow">if</font>( nTokenLen &gt;= nTokenMax-1 )
00439             {
00440                 nTokenMax = nTokenMax * 2 + 10;
00441                 pszToken = (<font class="keywordtype">char</font> *) CPLRealloc( pszToken, nTokenMax );
00442             }
00443 
00444             pszToken[nTokenLen] = *pszString;
00445             nTokenLen++;
00446         }
00447 
00448         pszToken[nTokenLen] = <font class="charliteral">'\0'</font>;
00449 
00450         <font class="keywordflow">if</font>( pszToken[0] != <font class="charliteral">'\0'</font> || bAllowEmptyTokens )
00451         {
00452             papszRetList = CSLAddString( papszRetList, pszToken );
00453         }
00454     }
00455 
00456     <font class="keywordflow">if</font>( papszRetList == NULL )
00457         papszRetList = (<font class="keywordtype">char</font> **) CPLCalloc(<font class="keyword">sizeof</font>(<font class="keywordtype">char</font> *),1);
00458 
00459     CPLFree( pszToken );
00460 
00461     <font class="keywordflow">return</font> papszRetList;
00462 }
00463 
00464 <font class="comment">/* static buffer to store the last error message.  We'll assume that error</font>
00465 <font class="comment"> * messages cannot be longer than 2000 chars... which is quite reasonable</font>
00466 <font class="comment"> * (that's 25 lines of 80 chars!!!)</font>
00467 <font class="comment"> */</font>
00468 <font class="keyword">static</font> <font class="keywordtype">char</font> gszCPLLastErrMsg[2000] = <font class="stringliteral">""</font>;
00469 <font class="keyword">static</font> <font class="keywordtype">int</font>  gnCPLLastErrNo = 0;
00470 
00471 <font class="keyword">static</font> void (*gpfnCPLErrorHandler)(CPLErr, <font class="keywordtype">int</font>, <font class="keyword">const</font> <font class="keywordtype">char</font> *) = NULL;
00472 
00473 <font class="comment">/**********************************************************************</font>
00474 <font class="comment"> *                          CPLError()</font>
00475 <font class="comment"> *</font>
00476 <font class="comment"> * This function records an error code and displays the error message</font>
00477 <font class="comment"> * to stderr.</font>
00478 <font class="comment"> *</font>
00479 <font class="comment"> * The error code can be accessed later using CPLGetLastErrNo()</font>
00480 <font class="comment"> **********************************************************************/</font>
00481 <font class="keywordtype">void</font>    CPLError(CPLErr eErrClass, <font class="keywordtype">int</font> err_no, <font class="keyword">const</font> <font class="keywordtype">char</font> *fmt, ...)<font class="keyword"></font>
00482 <font class="keyword"></font>{
00483     va_list args;
00484 
00485     <font class="comment">/* Expand the error message </font>
00486 <font class="comment">     */</font>
00487     va_start(args, fmt);
00488     vsprintf(gszCPLLastErrMsg, fmt, args);
00489     va_end(args);
00490 
00491     <font class="comment">/* If the user provided his own error handling function, then call</font>
00492 <font class="comment">     * it, otherwise print the error to stderr and return.</font>
00493 <font class="comment">     */</font>
00494     gnCPLLastErrNo = err_no;
00495 
00496     <font class="keywordflow">if</font> (gpfnCPLErrorHandler != NULL)
00497     {
00498         gpfnCPLErrorHandler(eErrClass, err_no, gszCPLLastErrMsg);
00499     }
00500     <font class="keywordflow">else</font>
00501     {
00502         fprintf(stderr, <font class="stringliteral">"ERROR %d: %s\n"</font>, gnCPLLastErrNo, gszCPLLastErrMsg);
00503     }
00504 
00505     <font class="keywordflow">if</font>( eErrClass == CE_Fatal )
00506         abort();
00507 }
00508 
00509 <font class="comment">/**********************************************************************</font>
00510 <font class="comment"> *                          CPLErrorReset()</font>
00511 <font class="comment"> *</font>
00512 <font class="comment"> * Erase any traces of previous errors.</font>
00513 <font class="comment"> **********************************************************************/</font>
00514 <font class="keywordtype">void</font>    CPLErrorReset()<font class="keyword"></font>
00515 <font class="keyword"></font>{
00516     gnCPLLastErrNo = 0;
00517     gszCPLLastErrMsg[0] = <font class="charliteral">'\0'</font>;
00518 }
00519 
00520 
00521 <font class="comment">/**********************************************************************</font>
00522 <font class="comment"> *                          CPLGetLastErrorNo()</font>
00523 <font class="comment"> *</font>
00524 <font class="comment"> **********************************************************************/</font>
00525 <font class="keywordtype">int</font>     CPLGetLastErrorNo()<font class="keyword"></font>
00526 <font class="keyword"></font>{
00527     <font class="keywordflow">return</font> gnCPLLastErrNo;
00528 }
00529 
00530 <font class="comment">/**********************************************************************</font>
00531 <font class="comment"> *                          CPLGetLastErrorMsg()</font>
00532 <font class="comment"> *</font>
00533 <font class="comment"> **********************************************************************/</font>
00534 <font class="keyword">const</font> <font class="keywordtype">char</font>* CPLGetLastErrorMsg()<font class="keyword"></font>
00535 <font class="keyword"></font>{
00536     <font class="keywordflow">return</font> gszCPLLastErrMsg;
00537 }
00538 
00539 <font class="comment">/**********************************************************************</font>
00540 <font class="comment"> *                          CPLSetErrorHandler()</font>
00541 <font class="comment"> *</font>
00542 <font class="comment"> * Allow the library's user to specify his own error handler function.</font>
00543 <font class="comment"> *</font>
00544 <font class="comment"> * A valid error handler is a C function with the following prototype:</font>
00545 <font class="comment"> *</font>
00546 <font class="comment"> *     void MyErrorHandler(int errno, const char *msg)</font>
00547 <font class="comment"> *</font>
00548 <font class="comment"> * Pass NULL to come back to the default behavior.</font>
00549 <font class="comment"> **********************************************************************/</font>
00550 
00551 <font class="keywordtype">void</font>     CPLSetErrorHandler(<font class="keywordtype">void</font> (*pfnErrorHandler)(CPLErr, <font class="keywordtype">int</font>, <font class="keyword">const</font> <font class="keywordtype">char</font> *))
00552 {
00553     gpfnCPLErrorHandler = pfnErrorHandler;
00554 }
00555 
00556 <font class="comment">/************************************************************************/</font>
00557 <font class="comment">/*                             _CPLAssert()                             */</font>
00558 <font class="comment">/*                                                                      */</font>
00559 <font class="comment">/*      This function is called only when an assertion fails.           */</font>
00560 <font class="comment">/************************************************************************/</font>
00561 
00562 <font class="keywordtype">void</font> _CPLAssert( <font class="keyword">const</font> <font class="keywordtype">char</font> * pszExpression, <font class="keyword">const</font> <font class="keywordtype">char</font> * pszFile,
00563                  <font class="keywordtype">int</font> iLine )<font class="keyword"></font>
00564 <font class="keyword"></font>
00565 <font class="keyword"></font>{
00566     CPLError( CE_Fatal, CPLE_AssertionFailed,
00567               <font class="stringliteral">"Assertion `%s' failed\n"</font>
00568               <font class="stringliteral">"in file `%s', line %d\n"</font>,
00569               pszExpression, pszFile, iLine );
00570 }
</div></pre><hr><address><small>Generated at Sun Mar 4 22:25:48 2001 for libgeotiff by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3-20001105 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
